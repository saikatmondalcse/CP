

// Date - 13/10/2022 , CF-1247C

How to represent a number n as the sum  of powers of 2? here optimally means minimum no of terms in sum (repetition of power is allowed)

let's say , no of terms in sum=t;

minimum t will be no of set bits in n and max t  will be n and t can be all values in between min t and max t;

example - 13

13 = 2^3+2^2+2^0 , tmin=3
13 = 2^3+2^1+2^1+2^0 , t=4
13 = 2^3+2^1+2^0+2^0+2^0 , t=5
13 = 2^3+2^0+2^0+2^0+2^0+2^0 , t=6
13 = 2^2+2^2+2^0+2^0+2^0+2^0+2^0 t=7
..................
..................
13= 2^1+2^0(11 times) t=12
13= 2^0(13 times) tmax=13


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


codeforces question -> product 1 modulo N

any subsequence product of all numbers less than n [1 2 ... n-1] be p
then p mod n is 1 implies p should be coprime with n

	
	

	suppose p%n=1

	gcd(1,n)=1
	gcd(p%n,n)=1
	gcd(p,n)=1

now p should be coprime with n means they should not have any common divisors
so, p should be a multiple of all the coprime numbers with respect to n that are less than n

now if p%n is 1 that means we can take all the coprime numbers less than n

else if p%n!=1 , lets p%n=k then k should also be a coprime number less than n

now if we remove k from the subsequence we will get a product that satisfies p mod n=1

proof:

let , p = a*k 

now p%n =  (a%n)*(k%n)

	k   =  (a%n) * k  // since k<n
	1   =  (a%n)
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

CF - 1721D

// check a number x can be generated by taking ai^bi and then taking & of all i 
// (a1^b1)&(a2^b2)&(a3^b3)....................&(an^bn)

// max of &(ai^bi) = ans

// then ans&(ai^bj)=(ans&ai)^(ans&bj) = ans

// (ans&ai)^ans -> the set bits in ans but not in ai -> that has to be compensated by (ans&bj) 


bool ispossible(int n,int a[],int b[],int x)
{
  unordered_map<int,int>mp;
  for(int i=0;i<n;i++)
  {
    mp[(a[i]&x)^x]++; // (ai&x)^x will give me the missing set bits(i.e. bits set in x but not set in ai) that we need from bi
    mp[b[i]&x]--;  // bi&x will provide the missing bits of x for some ai
  }
  for(auto x:mp)
  {
    if(x.second!=0)
      return false;
  }
  return true;
}

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
CF-1165E
if we have two sorted sequence of numbers, let's say, an and bn (a1≤a2≤a3≤...≤an and b1≤b2≤b3≤...≤bn) then the minimum sum of their multiplication (ai∗bj) is a1∗bn+a2∗bn−1+...+an∗b1 (you take the largest value of an and pair it with the lowest value of bn and vice versa) this is known as the rearrangement inequality

in all subarray of an array of size n 
the first element will be in  1*n subarrays
the second element will be in  2*(n-1) subarrays
....
the nth element will be in n*1 subarrays

**** the ith element will occur in  i⋅(n-i+1) subarrays  (1 based indexing) ***

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
******** making a vector with unique values in sorted order ***********

	sort(all(values));
	values.erase(unique(all(values)), values.end());

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

******************* eulerian path & circuit ***********************************

eulerian path , each edge visited once along traversal

eulerain circuit , after traversal  we arrive at starting source


condition for undirected graph

eulerian circuit or cycle => every node degree even
eulerian path    => no of odd degree node 2 or zero

condition for directed graph

eulerian circuit or cycle => every node indegree =  outdegree

eulerian path    => n-2 nodes indegree = outdegree
                    		rest 2 nodes :-
                        		indegree =  outdegree+1
                        		outdegree = indegree+1

for eulerian cycle :-
start doing dfs from any point and remove edge between current node and neighbour and call dfs for child and after traversal push current node to path , at the end we will return back to same source node

for eulerian path:-
for undirected graph ,start doing dfs from odd degree node for undirected graph , we will end at another odd degree node
for directed graph , start from more greater outdegree node and we will reach at greater indegree node


//:::::::::::::: code for undirected graph ::::::::::::

void dfs(vector<int>&vis,vector<set<int>>&adj,vector<int>&path,int curr)
{ 
    vis[curr]=1; 
    while(!adj[curr].empty())
    {
        auto it=adj[curr].begin();
        adj[curr].erase(it);
        adj[*it].erase(curr); // this should be off for directed graph
        dfs(vis,adj,path,*it);
    }
    path.pb(curr);
}

    vector<int>vis(n);
    vector<int>path;
    dfs(vis,adj,path,0);
    // path.pop_back();
    for(int i=0;i<n;i++)
    {
        if(vis[i]==0 && degree[i]>0)
            flag=false;
    }
 
    if(!flag)
        cout<<"IMPOSSIBLE\n";
    else
    for(auto x:path)
        cout<<x+1<<" ";

*/

************ Operator overloading for map ,set , priority_queue *************
// for prioriy_queue < , > order reverse

struct test{
    int x,y;
    bool operator < (const test &t)const  // operator overloading
    {

            return (this->x<t.x);
    }
};


***************************** Subset sum DP *********************************

const int mxsum=2e5;
const int mxn=100;
int dp[2][mxsum+1];
 
bool subsetsum(vector<int>&v,int sum)
{
    int n=v.size();

    dp[0][v[0]]=1,dp[0][0]=1;
    for(int i=1;i<n;i++)
    {
        for(int j=0;j<=mxsum;j++)
        {
            if(v[i]>j)
            {
                dp[i%2][j]=dp[(i+1)%2][j];
            }
            else
            {
                dp[i%2][j]=dp[(i+1)%2][j]||dp[(i+1)%2][j-v[i]];
            }
        }
    }
    
    return dp[(n-1)%2][sum];
}


******************* subsets in lexicographic order ******************

vector<vector<int>>subsets;

void generate(vector<int>a,int i,int n,vector<int>curr) // vector should be sorted before
{
	subsets.pb(curr);
	for(int j=i;j<n;j++)
	{
		curr.pb(a[j]);
		generate(a,j+1,n,curr);
		curr.pop_back();
	}
}



************** no of subsequenes with gcd  x from a given array **************************
LOGIC -
		g[i] -> denotes no of subsequence with gcd i
			
		let's say , we have all multiples of i 	
		
		for all multiples of i , the gcd of all the subsequence from its multiples will be multiple of i

		********* so g[i] =    no of subsequences with gcd (multiple of i) - g[2*i] - g[3*i]-g[4*i] ..........   ***************

    		no of subsequences with gcd = multiple of i -> 2^(no of multiples of i) - 1
		
		we have to calculate beforehand all g of multiples 



const int N=1e5;
const int mod=1e9+7;

void add_self(ll &a,ll b)
{
    a+=b;
    if(a>=mod)
        a-=mod;
}
void sub_self(ll &a,ll b)
{
    a-=b;
    if(a<0)
        a+=mod;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int n;
    cin>>n;
    vector<ll>frq(N+1);
    vector<int>a(n);
    for(int i=0;i<n;i++){
        cin>>a[i];
        frq[a[i]]++;
    }
    ll g[N+1]={0};    
    for(int i=N;i>=1;i--)
    {
        ll mul=frq[i];
        for(int j=2*i;j<=N;j+=i)
        {
            mul+=frq[j];
            sub_self(g[i],g[j]);
        }
        add_self(g[i],power(2,mul)-1);
    }
    cout<<g[1];
    return 0;
}




******************* Derangement of permutation ******************************


D[n] = n! * ( 1 -1/(1!) + 1/(2!) - 1/(3!) + ........... + (-1)^n / n! )

D[0] = 1 , D[1] = 0 , D[2] = 1 , D[3] = 2 , D[4] = 9


Recurrence relation ->
				D[n] = n*D[n-1] + (-1)^n   


******************** String Polynomial Hashing *************************************

if number string then change 'a' to '0'


const int N=3500;
ll pre[N+1];
ll mod=1e9+7;
ll inv[N+1];

void add_self(ll &a,ll b)
{
	a+=b;
	if(a>=mod)
		a-=mod;
}

ll power(ll a,ll b)
{
    ll result=1;
    while(b>0)
    {
        if(b%2==1)
        {
            result= (result*a)%mod;
        }
        a= (a*a)%mod;
        b=b/2;
    }
    return result;
}
 
void build(string &s,int n)
{
    ll p=31;
    ll k=1;
    pre[0]=s[0]-'a'+1;
    inv[0]=1;
    for(ll i=1;i<n;i++)
    {
        k*=p;
        k%=mod;
        inv[i]=power(k,mod-2);
        pre[i]=(pre[i-1]+(s[i]-'a'+1)*k)%mod;
    }
}
 
ll substrhash(ll l,ll r)
{
    if(l==0)
        return pre[r];
    ll val=(pre[r]-pre[l-1]+mod)%mod;
    val*=inv[l];
    val%=mod;
    return val;
}

int compare_substring(string &s,int l1,int r1,int l2,int r2) // 1 -> first one greater , 0 -> equal  , -1 -> second one greater
{
	int len1=r1-l1+1,len2=r2-l2+1;

	int len=min(len1,len2);

	int l=0,r=len+1;
	int mid;
	while(r-l>1)
	{
		mid=(l+r)/2;
		ll f=substrhash(l1,l1+mid-1);
		ll s=substrhash(l2,l2+mid-1);
		if(f==s)
			l=mid;
		else
			r=mid;
	}
	if(l==len)
	{
		if(len1==len2)
			return 0;
		else if(len1>len2)
			return 1;
		else
			return -1;
	}
	else 
	{
		if(s[l1+l] > s[l2+l])
		{
			return 1;
		}
		else
			return -1;
	}
}


//:::::::::::::::::::::::: DSU :::::::::::::::::::::::::::::::::::;

vector<int>par;
vector<int>siz;
 
void makeset(int n)
{
	par.resize(n);
	siz.resize(n);
    for(int i=0;i<n;i++)
    {
        par[i]=i;
        siz[i]=1;
    }
}
 
int findpar(int node)
{
    if(node==par[node])
        return node;
    else
        return par[node]=findpar(par[node]);
}
 
void merge(int u,int v)
{
 
    u=findpar(u);
    v=findpar(v);
    if(u==v)
    	return;
    if(siz[u]<siz[v])
    {
        par[u]=v;
        siz[v]+=siz[u];
    }
    else
    {
        par[v]=u;
        siz[u]+=siz[v];
    }
}


************************************* 2d prefix sum *********************************

	// 2 D prefix sum
    	vector<vector<int>> pre(n,vector<int>(n));

   	for(int i=0;i<n;i++)
   	{
   		for(int j=0;j<n;j++)
   		{
   			if(i+1<n)
	   			pre[i+1][j]+=pre[i][j];
   			if(j>0)
   			pre[i][j]+=pre[i][j-1];
   		}
   	}
	auto query = [&](int x1,int y1,int x2,int y2)->int{
		int ans=pre[x2][y2];
   		if(y1>0)
   			ans-=pre[x2][y1-1];
   		if(x1>0)
   			ans-=pre[x1-1][y2];
   		if(x1>0 && y1>0)
   			ans+=pre[x1-1][y1-1];
   		return ans;
	};




********************************  sqrt binary search *********************************************

long long int_sqrt (long long x) {
  long long ans = 0;
  for (ll k = 1LL << 30; k != 0; k /= 2) {
    if ((ans + k) * (ans + k) <= x) {
      ans += k;
    }
  }
  return ans;
}


***************************** ka mod b max value ***********************************************

ka % b where k is a integer ->  b - gcd(a,b) 



************************* end points of diameter in tree *******************************************

#include<bits/stdc++.h>
using namespace std;
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define ff first
#define ss second
#define sz(x) ((int)(x).size())
typedef long long ll;

#ifndef ONLINE_JUDGE
#define deb(x) cout<<#x<<" "<<x<<"\n"
#define deb2(x,y) cout<<"[ "<<#x<<"="<<x<<","<<#y<<"="<<y<<" ]\n"
#define deba(x,n) cout<<#x<<": [ ";for(int i=0;i<n;i++){cout<<x[i]<<" ";}cout<<"]\n"; 
#define deba2(x,n,m) cout<<#x<<":\n";for(int i=0;i<n;i++){for(int j=0;j<m;j++)cout<<x[i][j]<<" ";cout<<"\n";}; 
#define debe(x) cout<<#x<<":[ ";for(auto i:x){cout<<i<<" ";}cout<<"]\n"; 
#else
#define deb(x) 
#define deb2(x,y) 
#define deba(x,n) 
#define deba2(x,n,m) 
#define debe(x) 
#endif

const int N=1e5;
vector<int>adj[N+1];

int d,e;
void dfs(int curr,int p,int dist)
{
    if(dist>d)
    {
        d=dist;
        e=curr;
    }
    for(auto child:adj[curr])
    {
        if(child!=p)
        {
            dfs(child,curr,dist+1);
        }
    }
}
int furthest(int root)
{
    d=-1,e=-1;
    dfs(root,-1,0);
    return e;
}


int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    int n;
    cin>>n;

    for(int i=0;i<n-1;i++)
    {
        int a,b;
        cin>>a>>b;
        --a,--b;
        adj[a].pb(b);
        adj[b].pb(a);
    }
    int e1=furthest(0);
    int e2=furthest(e1);
    return 0;
}


//::::::::::::::::::::::::::::::: Marble removal dp O(n^4) ::::::::::::::::::::::::::

    // dp[l][r][k] -> answer for segment l to r with k extra a[l] elements to the left

    // [l..r] with extra k elements with value a[l] in left side

    // option 1) include a[l] in extra k elements prefix 

    // -> (k+1)*(k+1) then we are left with dp[l+1][r][0]
    
    // option 2) if l+1<=i<=r , a[i]==a[l] , then collpase all the substring between the two indices to merge them

    //           dp[l+1][i-1][0] + dp[i][r][k+1]  

    // dp[l][r][k] =  (k+1)*(k+1) + dp[l+1][r][0] -> ak+1 + dp[l+1][r][0]

    //             =  dp[l+1][i-1][0] + dp[i][r][k+1]


//::::::::::::::::::::: erase in ordered_multiset ::::::::::::::::::::::::

    int val;
    int p=os.ook(val);
    auto it=os.fbo(p);
    if(*it==val) // to erase val , otherwise it will erase first value >=val
        os.erase(it);

//::::::::::::::::::::::::  Grid bfs :::::::::::::::::::::::::::::::

ll inf=1e17;

// grid 0 -> means blocked , 1 means clear path

vector<vector<ll>>shortest(int sx,int sy,vector<vector<ll>>&grid,int h,int w)
{
    vector<vector<ll>>dist(h,vector<ll>(w,inf));
    vector<int>dx={0,0,1,-1};
    vector<int>dy={1,-1,0,0};


    queue<pair<int,int>>q;

    dist[sx][sy]=0;
    q.push({sx,sy});

    function<bool(int,int)>isvalid=[&](int x,int y)->bool{
        return (x>=0 && x<h && y>=0 && y<w);
    };

    while(!q.empty())
    {
        q.pop();
        for(int i=0;i<4;i++)
        {
            int new_x=x+dx[i],new_y=y+dy[i];
        int x=q.front().ff,y=q.front().ss;
            if(isvalid(new_x,new_y) && grid[new_x][new_y]==1 && dist[new_x][new_y]==inf )
            {
                dist[new_x][new_y]=dist[x][y]+1;
                q.push({new_x,new_y});
            }
        }
    }

    return dist;
}   

//::::::::::::::::::::::::::::::::: generate divisors from prime factorization ::::::::::::::::::::::::::

vector<int>generate_div(vector<pair<int,int>>pr)
{
    vector<int>divisors;

    divisors.pb(1);

    for(auto p:pr)
    {
        int s=sz(divisors);
        for(int i=0;i<s;i++)
        {
            int x=divisors[i];
            int y=p.ff;
            for(int i=1;i<=p.ss;i++){
                divisors.pb(x*y);
                y*=(p.ff);
            }
        }   
    }
    sort(all(divisors));
    return divisors;
}


//::::::::::::::::::::::: segment tree ::::::::::::::::::::::::::::::::::

template<typename T>
struct SegTree{

    vector<T>tree;
    T ne=0; // change neutral
    int sze;

    T combine(T a,T b)
    {
        T c=a+b;  // operation
        return c;
    }
    void build(vector<ll>a)
    {
        int n=sz(a);
        ll ne2=0; // change neutral element of array
        sze=n;  
        while(sze&(sze-1))
        {
            sze++;
        }
        tree.resize(2*sze);
        for(int i=0;i<sze;i++)
        {
            if(i<n)
                tree[sze+i]=a[i];
            else
                tree[sze+i]=ne2;
        }
        for(int i=sze-1;i>=1;i--)
        {
         tree[i]=combine(tree[2*i],tree[2*i+1]);
        }
    }


    T query(int s,int e,int l,int r,int i)
    {
        if(s>r || e<l)
            return ne;
        else if(s>=l && e<=r)
            return tree[i];
        else
        {
            int mid=(s+e)/2;

            T left=query(s,mid,l,r,2*i);
            T right=query(mid+1,e,l,r,2*i+1);
            return combine(left,right);
        }
    }

    void Pupdate(int i,T val)
    {
        tree[sze+i]=val;

        for(int j=(sze+i)/2;j>=1;j/=2)
        {
            tree[j]=combine(tree[2*j],tree[2*j+1]);
        }
    }

    //::::::::::: for range update and point query :::::::::::::::::::
 
    void static_range_update(int s,int e,int l,int r,int i,ll ax,ll dx){
 
        if(s>r || e<l)
            return;
        else if(s>=l && e<=r)
        {
            // tree[i] do operation lazily
        }
        else
        {
            int mid=(s+e)/2;
            static_range_update(s,mid,l,r,2*i,ax,dx);
            static_range_update(mid+1,e,l,r,2*i+1,ax,dx);
        }
    }
 
    T range_point_query(int i)
    {
        T inc=0;

        int l=i,r=i;
        int j=(sze+i);
        int k=1;
        for(j;j>=1;j/=2)
        {
            // tree[j].ai+(tree[j].l-i)*tree[j].di
            inc+=(tree[j].ai+(i-l)*tree[j].di);
            if(j&1)
            {
                l-=k;
            }
            else
                r+=k;
            k*=2;
        }

        return inc;
    } 

};

//::::::::::::::::::: stars and bars :::::::::::::::::::::::::::::::::::::::::

no of non negative solution of x1+x2+x3+....+xr = n -----> (n+r-1)C(r-1) = (n+r-1)C(n)


//:::::::::::::::::::::: combinatorics problem ::::::::::::::::::::::::::::::::

Let's say , we have two seuqence A1,A2,..,An and B1,B2,....,Bm . now no of ways of merging the sequences such that the relatively ordering in sequence A and B are maintained ->
that is A1 should come before A2,A2 should come before A3.....

no of ways = (n+m)!/(n! m!) [ proof by stars and bars ]

for three sequences -> A1...An , B1...Bm , C1....Ck  =>  (n + m + k)! / (n! m! k!) , mulitnomial coefficient 

this can be further extended upto any number of sequences 


// ::::::::::::::::::::::: combinatorics equation ::::::::::::::::::::::::::::::::::::::

(nC0*mC0 + nC1*mC1 + nC2*mC2 + .... + nC(min(n,m)) * mC(min(n,m)) =  (n+m)Cm or (n+m)Cn



//::::::::::::::::::::::: Segment Tree with lazy propagation ::::::::::::::::::::::::::

range update -> set [L...R]  to x
range query  -> calculate sum from [L....R]

template<typename T>
struct SegTree{

    vector<T>tree;
    T ne=0; // change neutral
    int sze;
    vector<bool>lazy;
    vector<int>lazyvalue;
    T combine(T a,T b)
    {
        T c=a+b;  // operation
        return c;
    }
    void build(vector<int>a)
    {
        int n=sz(a);
        int ne2=0; // change neutral element of array
        sze=n;  
        while(sze&(sze-1))
        {
            sze++;
        }
        tree.resize(2*sze);
        lazy.resize(2*sze,false);
        lazyvalue.resize(2*sze);
        for(int i=0;i<sze;i++)
        {
            if(i<n)
                tree[sze+i]=a[i];
            else
                tree[sze+i]=ne2;
        }
        for(int i=sze-1;i>=1;i--)
        {
         tree[i]=combine(tree[2*i],tree[2*i+1]);
        }
    }



//::::::::::: range update range query:::::::::::::::::::::

//::::::::: assign l to r to x and find sum from l to r

    void Rupdate(int s,int e,int l,int r,int i,ll a)
    {
        if(lazy[i])
        {
            tree[i]=(e-s+1)*lazyvalue[i];
            if(s!=e)
            {
                lazy[2*i]=1;
                lazyvalue[2*i]=lazyvalue[i];
                lazy[2*i+1]=1;
                lazyvalue[2*i+1]=lazyvalue[i];
            }
            lazy[i]=0;
            lazyvalue[i]=0;
        }
        if(s>r || e<l)
            return;
        else if(s>=l && e<=r)
        {
            tree[i]=(e-s+1)*a;
            if(s!=e)
            {
                lazy[2*i]=1;
                lazyvalue[2*i]=a;
                lazy[2*i+1]=1;
                lazyvalue[2*i+1]=a;
            }
        }
        else
        {
            int mid=(s+e)/2;
            Rupdate(s,mid,l,r,2*i,a);
            Rupdate(mid+1,e,l,r,2*i+1,a);
            tree[i]=combine(tree[2*i],tree[2*i+1]);
        }
    }

    T query(int s,int e,int l,int r,int i)
    {

        if(lazy[i])
        {
            tree[i]=(e-s+1)*lazyvalue[i];
            if(s!=e)
            {
                lazy[2*i]=1;
                lazyvalue[2*i]=lazyvalue[i];
                lazy[2*i+1]=1;
                lazyvalue[2*i+1]=lazyvalue[i];
            }
            lazy[i]=0;
            lazyvalue[i]=0;
        }
        if(s>r || e<l)
            return ne;
        else if(s>=l && e<=r)
        {
            return tree[i];
        }
        else
        {
            int mid=(s+e)/2;
            T left=query(s,mid,l,r,2*i);
            T right=query(mid+1,e,l,r,2*i+1);
            return combine(left,right);
        }
    }

};


//:::::::::::::::: type -2 :::::::::::::::::::::::::::::::
range update -> add x to [L...R]  
range query  -> calculate min from [L....R]\


template<typename T>
struct SegTree{

    vector<T>tree;
    T ne=1e18L; // change neutral
    int sze;
    vector<bool>lazy;
    vector<ll>lazyvalue;
    T combine(T a,T b)
    {
        T c=min(a,b);  // operation
        return c;
    }
    void build(vector<int>a)
    {
        int n=sz(a);
        ll ne2=1e18L; // change neutral element of array
        sze=n;  
        while(sze&(sze-1))
        {
            sze++;
        }
        tree.resize(2*sze);
        lazy.resize(2*sze,false);
        lazyvalue.resize(2*sze);
        for(int i=0;i<sze;i++)
        {
            if(i<n)
                tree[sze+i]=a[i];
            else
                tree[sze+i]=ne2;
        }
        for(int i=sze-1;i>=1;i--)
        {
         tree[i]=combine(tree[2*i],tree[2*i+1]);
        }
    }



//::::::::::: range update range query:::::::::::::::::::::

//::::::::: increment l to r to by x and find min from l to r

    void Rupdate(int s,int e,int l,int r,int i,ll a)
    {
        if(lazy[i])
        {
            tree[i]+=lazyvalue[i];
            if(s!=e)
            {
                lazy[2*i]=1;
                lazyvalue[2*i]+=lazyvalue[i];
                lazy[2*i+1]=1;
                lazyvalue[2*i+1]+=lazyvalue[i];
            }
            lazy[i]=0;
            lazyvalue[i]=0;
        }
        if(s>r || e<l)
            return;
        else if(s>=l && e<=r)
        {
            tree[i]+=a;
            if(s!=e)
            {
                lazy[2*i]=1;
                lazyvalue[2*i]+=a;
                lazy[2*i+1]=1;
                lazyvalue[2*i+1]+=a;
            }
        }
        else
        {
            int mid=(s+e)/2;
            Rupdate(s,mid,l,r,2*i,a);
            Rupdate(mid+1,e,l,r,2*i+1,a);
            tree[i]=combine(tree[2*i],tree[2*i+1]);
        }
    }

    T query(int s,int e,int l,int r,int i)
    {

        if(lazy[i])
        {
            tree[i]+=lazyvalue[i];
            if(s!=e)
            {
                lazy[2*i]=1;
                lazyvalue[2*i]+=lazyvalue[i];
                lazy[2*i+1]=1;
                lazyvalue[2*i+1]+=lazyvalue[i];
            }
            lazy[i]=0;
            lazyvalue[i]=0;
        }
        if(s>r || e<l)
            return ne;
        else if(s>=l && e<=r)
        {
            return tree[i];
        }
        else
        {
            int mid=(s+e)/2;
            T left=query(s,mid,l,r,2*i);
            T right=query(mid+1,e,l,r,2*i+1);
            return combine(left,right);
        }
    }
};







